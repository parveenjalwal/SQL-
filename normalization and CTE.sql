# this section contains normlization and commen table expration 

use mavenmovies ;

# starting from the nomlization first 
# qustion 1 : dentify a table in the Sakila database that violates 1NF. Explain how you would normalize it to achieve 1NF ? 

# answer >> 

select * from payment; 
# IN this payment table payment data is clearly voilating  first normalization from 
# how beuase it has payment data as well as time in same column together 
# which cause barrier while filtring data based on one spcific fector such as time , that time sql will be filtring time along with data 
# therfor i am here spliting these both into diffrent diffrent column for batter access of data 

select payment_id, customer_id, staff_id, rental_id, amount,
date(payment_date) as payment_date , 
time(payment_date) as payment_time 
from payment ; 

# now  sql can more fatch data more appropriatly rather then previously stored data 
# thougt i have fatched data in new column but if we want so this data can be stored parmanently also .. 



# qustion 2 :  Identify a table in the Sakila database that violates 1NF. Explain how you would normalize it to achieve 1NF.

#answer >> 
# here we have table which vilates the 2NF -- 

# film_category

# | -------------------------------------------------- | 
# | film_id | category_id | film             |  cateogry | 
# |   1     |      2      | ACADEMY DINOSAUR | Animation |
# |   2     |      3      | 'ACE GOLDFINGER  | Children  |


# here above film column is dependent on film_id and another hand catogery col is depent on category_id 
# these both leads to two primary key , which voilates 2NF becasue it has two primary key 
# # solution 
# removing film and category column from film_catogery 
# store film column in film table 
# store category column in category table 



-- Question 3  Identify a table in Sakila that violates 3NF. Describe the transitive dependencies present and outline the steps to normalize the table to 3NF.  

-- A table violates Third Normal Form (3NF) if:
-- A non-key column is dependent on another non-key column** rather than on the primary key.

### Example: `customer` table
#| customer_id | address_id | city | country |
#|-------------|-----------|------|---------|
#| 1           | 101       | London  | UK  |
#| 2           | 102       | Paris   | France |

#Here, `country` depends on `city`, which depends on `address_id`, **creating a transitive dependency**.

## Normalization to Achieve 3NF:
-- Create a separate `city` table** with `city_id` and `country_id`.
-- Modify `customer` to store `city_id` instead of `city` and `country`**.
-- Link `city_id` to `country_id` in a separate `country` table**.





-- Question 4  
# Take a specific table in Sakila and guide through the process of normalizing it from the initial unnormalized form up to at least 2NF.  

#Example: `rental` table (Unnormalized)
#| rental_id | customer_id | customer_name | film_id | film_title | rental_date |
#|-----------|------------|--------------|---------|-----------|-------------|
#| 1         | 101        | John Doe     | 10      | Matrix    | 2024-01-10  |

#1NF: Split customer details into `customer` table.
#2NF: Ensure no partial dependencies by storing `film_title` in `film` table.

#Final `rental` table:
#| rental_id | customer_id | film_id | rental_date |
#|-----------|------------|---------|-------------|
#| 1         | 101        | 10      | 2024-01-10  |

#Now, `customer_name` and `film_title` are stored in separate tables.






# qustion 5 : a. Write a query using a CTE to retrieve the distinct list of actor names and the number of films they 
			#    have acted in from the actor and film_actor tables.

#answer >> 
with actor_movies_count as 
(select distinct actor_id as actor_ids , 
count(*) as movies_numbers 
from film_actor
group by actor_id )
select concat(first_name,last_name) as full_name , movies_numbers 
from actor a 
join actor_movies_count amc on amc.actor_ids = a.actor_id ;



#qustion 6: Create a CTE that combines information from the film and language tables to display the film title,  language name, and rental rate.  ? 

#answer >> 
with movie_info as 
(select language_id ,title , rental_rate 
from film ) 
select title , name , rental_rate 
from language l 
join movie_info mi 
on l.language_id = mi.language_id ; 



#qustion 7:  Write a query using a CTE to find the total revenue generated by each customer (sum of payments) 
            #from the customer and payment tables.

# answer >> 
with cust_revanue as 
( select customer_id , 
sum(amount) as total_amount 
from payment 
group by customer_id ) 
select  full_name , total_amount 
from customer c 
join cust_revanue cr 
on c.customer_id = cr.customer_id ; 




#qustion 8 : . Utilize a CTE with a window function to rank films based on their rental duration from the film table ? 

#answer >> 
with movie_ranks as 
(select dense_rank() over (order by rental_duration desc ) as film_ranks , 
title , rental_duration 
from film ) 
select * from 
movie_ranks ; 




#qustion 9 : Create a CTE to list customers who have made more than two rentals, and then join this CTE with the  customer table to retrieve additional  ? 

# answer >> 
with cust_rentals as 
(select customer_id , 
count(*) as total_rental 
from rental 
group by customer_id
having total_rental > 2  )
select full_name , email , create_Date , total_rental 
from customer c
join cust_rentals cr 
on c.customer_id = cr.customer_id 
order by total_rental ; 




#qustion 10 :  Write a query using a CTE to find the total number of rentals made each month, considering the  rental_date from the rent ? 

#answer >> 
select * from rental ; 

with monthly_rentals as 
(select 
month(date(rental_date)) as rental_month , 
count(rental_id) as total_rental
from rental 
group by rental_month ) 
select * 
from monthly_rentals 
order by rental_month ; 




# qustion 11 : Create a CTE to generate a report showing pairs of actors who have appeared in the same film  together, using the film_actor tab 

# answer >> 
select * from actor ; 
select * from film_actor ; 
select * from film ; 

with actor_pairs as 
(select concat(first_name," ",last_name) as full_name,
title 
from film f 
left join film_actor fc  on f.film_id = fc.film_id 
left join actor a on fc.actor_id = a.actor_id )
select * 
from actor_pairs ; 



# Question 12  Implement a recursive CTE to find all employees in the staff table who report to a specific manager, considering the reports_to column.  

#answer >> 
WITH RECURSIVE staff_hierarchy AS (
    SELECT staff_id, first_name, last_name, reports_to
    FROM staff
    WHERE reports_to IS NULL

    UNION ALL

    SELECT s.staff_id, s.first_name, s.last_name, s.reports_to
    FROM staff s
    JOIN staff_hierarchy sh ON s.reports_to = sh.staff_id
)
SELECT * FROM staff_hierarchy;


 

 
 

